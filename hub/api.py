import asyncio
from fastapi import (
    APIRouter,
    responses,
    Request,
    Response,
    status,
    WebSocket,
    HTTPException,
)
import os
import markdown
from sqlmodel import Session, SQLModel, select
from typing import Dict, List
import json
import jsonrpc
import logging
import hub.db as db
import hub.transmutation as transmutation
import libs.persistent_websocket.python.persistent_websocket as persistent_websocket

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)  # will be throttled by handler log level (file, console)
router = APIRouter()

###
### web API
###

#                                              read          create      update†       delete
# -------------------------------------------- GET --------- POST ------ PATCH ------- DELETE ------
# ⍉ /v1/managers/🗝                            view self     --          update self   delete self
# ⍉ /v1/managers/🗝/bases                      list bases    new base    --            --
# ⍉ /v1/managers/🗝/bases/18                   view base     --          update base   delete base
# ⍉ /v1/managers/🗝/bases/18/clients           list clients  new client  --            --
# ⍉ /v1/managers/🗝/bases/18/clients/4         view client   --          update client delete client
# ⍉ /v1/managers/🗝/bases/18/users             list users    new user    --            --
# ⍉ /v1/managers/🗝/bases/18/v1/users/🗝       view user     --          update user   delete user
#   /v1/coupons/🧩/managers                    --            new mngr    --            --
# ⍉ /v1/admins/🔑/managers                     list mngrs    --          --            --
# ⍉ /v1/admins/🔑/managers/🗝                  view mngr     --          update mngr   delete mngr
# #️⃣ /v1/admins/🔑/coupons                     list coupons  new coupon  --            --
# ⍉ /v1/admins/🔑/accounts/🗝                  view coupon   --          update coupon delete coupon
# idempotent                                   ✅            —           ✅            ✅
# 200 OK                                       ✅            —           ✅            —
# 201 created                                  —             —           —             —
# 204 no content                               —             —           —             ✅
# ⍉ not yet implemented
# #️⃣ CLI only (may implement in app later)
# 🔑 admin login key
# 🗝 manager (or admin) login key
# 🧩 coupon code
# †  cleint should send only modified fields
# ‡  new coupon or manager
# §  delete coupon, manager, or user
# https://medium.com/hashmapinc/rest-good-practices-for-api-design-881439796dc9

messages: Dict[str, persistent_websocket.PersistentWebsocket] = dict()  # one entry for each conv_id

# FIXME: to limit brute-force attacks, throttle any IP address with 4 connects in 60 seconds; https://github.com/tiangolo/fastapi/issues/448


@router.websocket('/rpc{rpc_ver}/{auth_account}/{conv_id}')
async def rpc(websocket: WebSocket, rpc_ver: str, auth_account: str, conv_id: str):
    """Main JSON-RPC entry point.

    :param rpc_ver: RPC version requested by app; must be incremented when a method is changed
           or added; hub must support all of RPC versions
    :param auth_account: any valid account; used only for establishing WebSocket connection
    :param conv_id: conversation ID; unique, generated by app to uniquely identify this session
    """
    try:
        account = db.Account.validate_login_key(
            auth_account, allowed_kinds=db.admin_manager_or_coupon
        )
    except Exception as e:
        if isinstance(e, jsonrpc.exceptions.JSONRPCDispatchException):
            logger.info(f"B12874 invalid auth_account: {e.error.message}")
        else:
            logger.info(f"B23915 validation error {type(e)}")
        await websocket.close()
        # respond with '403 Forbidden' here (same as invalid URLs) to make it harder for those
        # without a valid coupon or login key to detect that this is a BitBurrow hub;
        # test with curl as WebSocket client:
        #     HOST="vxm.example.org:8443"
        #     URL="https://$HOST/rpc1/BBBBBBBBBBBBBBBBBB/4"
        #     curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" \
        #         -H "Sec-WebSocket-Key: $(openssl rand -base64 16)" \
        #         -H "Sec-WebSocket-Version: 13" \
        #         -H "Host: $HOST" -H "Origin: $URL" "$URL"
        raise HTTPException(status_code=403, detail="")
    if conv_id not in messages:
        log_id = conv_id[-4:]  # only for logging
        pws_log = logging.getLogger('persistent_websocket')
        pws_log.setLevel(logging.DEBUG)  # will be throttled by handler log level (file, console)
        messages[conv_id] = persistent_websocket.PersistentWebsocket(log_id, pws_log)
    try:
        await websocket.accept()
        # Notes on RPC options (see https://pypi.org/project/PACKAGE/ where PACKAGE is below):
        #     * fastapi-jsonrpc → can only use HTTP (no PersistentWebsocket); snyk.io 72
        #     * grpc → uses HTTP/2; does not gracefully recover from disconnects; snyk.io 63
        #     * json-rpc → simple, no async but seems to work well; snyk.io 71
        async for m in messages[conv_id].connected(websocket):  # process RPC requests, send results
            response = jsonrpc.JSONRPCResponseManager.handle(m, jsonrpc.dispatcher)
            await messages[conv_id].send(json.dumps(db.simplify(response.data)))
    except persistent_websocket.PWUnrecoverableError:
        del messages[conv_id]  # data is no longer usable


@jsonrpc.dispatcher.add_method
def create_manager(coupon: str):
    account = db.Account.validate_login_key(coupon, allowed_kinds=db.coupon)  # verfiy validity
    return db.Account.new(db.Account_kind.MANAGER)
    # do not store login_key!


@jsonrpc.dispatcher.add_method
def list_bases(login_key: str):
    account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
    with Session(db.engine) as session:
        statement = select(db.Base).where(db.Base.account_id == account.id)
        return list(session.exec(statement))


@jsonrpc.dispatcher.add_method
def create_base(login_key: str, task_id: int, base_id: int):
    account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
    if task_id == 0:
        base_id = db.Base.new(account.id)
        task_id = transmutation.transmute_next_task(task_id)
    task = transmutation.transmute_task(task_id)
    return {
        'method': task['method'],
        'params': task['params'],
        'next_task': transmutation.transmute_next_task(task['id']),
        'base_id': base_id,
    }


# @router.websocket('/v1/managers/{login_key}/bases/{base_id}/setup')
# async def websocket_setup(websocket: WebSocket, login_key: str, base_id: int):
#     account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
#     await websocket.accept()
#     pws_log = logging.getLogger('persistent_websocket')
#     pws_log.setLevel(logging.DEBUG)  # will be throttled by handler log level (file, console)
#     messages = persistent_websocket.PersistentWebsocket(base_id, pws_log)
#     runTasks = transmutation.BaseSetup(websocket, messages)
#     try:
#         await runTasks.transmute_steps()
#     except asyncio.exceptions.CancelledError:
#         logger.info(f"B15058 transmute canceled")


# @router.websocket('/v1/managers/{login_key}/bases/{base_id}/proxy')
# async def websocket_proxy(websocket: WebSocket, login_key: str, base_id: int):
#     account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
#     await websocket.accept()
#     tcp_websocket = transmutation.TcpWebSocket(
#         tcp_port=30915, tcp_address='127.0.0.1', ws=websocket
#     )
#     await tcp_websocket.start()
#     try:
#         await websocket.close()
#     except Exception as e:
#         logger.error(f"B38264 WebSocket error: {e}")  # e.g. websocket already closed


# messages: Dict[str, persistent_websocket.PersistentWebsocket] = dict()  # one entry for each client


# @router.websocket('/v1/pw/{client_id}')
# async def websocket_testahwibb(websocket: WebSocket, client_id: str):
#     if client_id not in messages:
#         # FIXME: mitigate DOS attack via opening a bunch of unique connections
#         messages[client_id] = persistent_websocket.PersistentWebsocket(client_id)
#         # (TESTING) messages[client_id].chaos = 50  # 5% chance of closing WebSocket on each send or receive
#         persistent_websocket.logger.setLevel(logging.DEBUG)
#     try:
#         await websocket.accept()
#         async for m in messages[client_id].connected(websocket):
#             print(f"------------------------------------------ {client_id} incoming: {m.decode()}")
#     except persistent_websocket.PWUnrecoverableError:
#         del messages[client_id]  # data is no longer usable


@router.get('/bitburrow/{page}')
async def welcome_page(page:str):
    mdFileNames={
        'welcome': 'index.md',
    }
    if page in mdFileNames.keys():
        fileName=mdFileNames[page]
        current_dir = os.path.dirname(os.path.abspath(__file__))
        path = os.path.join(current_dir, 'web', fileName)
        file=open(path,'r')
        mdStr=file.read()
        file.close()
        outerHTMLFile=open(os.path.join(current_dir, 'web', 'outer-HTML.html'))
        out=""
        for line in outerHTMLFile.readlines():
            if '<!--markdown-here-->' in line:
                out+=markdown.markdown(mdStr)
            else:
                out+=line
        outerHTMLFile.close()
        return Response(out,media_type='text/html')
    elif page =='css.css':
        current_dir = os.path.dirname(os.path.abspath(__file__))
        path = os.path.join(current_dir, 'web', 'css.css')
        return Response(open(path).read(), media_type='text/css')
