import asyncio
from fastapi import (
    APIRouter,
    responses,
    Request,
    status,
    WebSocket,
    HTTPException,
)
from sqlmodel import Session, SQLModel, select
from typing import Dict, List
import json
import jsonrpc
import logging
import os
import sys
import hub.db as db
import hub.transmutation as transmutation

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(os.path.join(base_dir, "libs", "python"))
import persistent_websocket.persistent_websocket as persistent_websocket

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)  # will be throttled by handler log level (file, console)
router = APIRouter()

###
### web API
###

#                                              read          create      update†       delete
# -------------------------------------------- GET --------- POST ------ PATCH ------- DELETE ------
# ⍉ /v1/managers/🗝                            view self     --          update self   delete self
# ⍉ /v1/managers/🗝/servers                    list servers  new server  --            --
# ⍉ /v1/managers/🗝/servers/18                 view server   --          update server delete server
# ⍉ /v1/managers/🗝/servers/18/clients         list clients  new client  --            --
# ⍉ /v1/managers/🗝/servers/18/clients/4       view client   --          update client delete client
# ⍉ /v1/managers/🗝/servers/18/users           list users    new user    --            --
# ⍉ /v1/managers/🗝/servers/18/v1/users/🗝     view user     --          update user   delete user
#   /v1/coupons/🧩/managers                    --            new mngr    --            --
# ⍉ /v1/admins/🔑/managers                     list mngrs    --          --            --
# ⍉ /v1/admins/🔑/managers/🗝                  view mngr     --          update mngr   delete mngr
# #️⃣ /v1/admins/🔑/coupons                     list coupons  new coupon  --            --
# ⍉ /v1/admins/🔑/accounts/🗝                  view coupon   --          update coupon delete coupon
# idempotent                                   ✅            —           ✅            ✅
# 200 OK                                       ✅            —           ✅            —
# 201 created                                  —             —           —             —
# 204 no content                               —             —           —             ✅
# ⍉ not yet implemented
# #️⃣ CLI only (may implement in app later)
# 🔑 admin login key
# 🗝 manager (or admin) login key
# 🧩 coupon code
# †  cleint should send only modified fields
# ‡  new coupon or manager
# §  delete coupon, manager, or user
# https://medium.com/hashmapinc/rest-good-practices-for-api-design-881439796dc9


messages: Dict[str, persistent_websocket.PersistentWebsocket] = dict()  # one entry for each conv_id

# FIXME: to limit brute-force attacks, throttle any IP address with 4 connects in 60 seconds; https://github.com/tiangolo/fastapi/issues/448


@router.websocket('/rpc{rpc_ver}/{auth_account}/{conv_id}')
async def rpc(websocket: WebSocket, rpc_ver: str, auth_account: str, conv_id: str):
    """Main JSON-RPC entry point.

    :param rpc_ver: RPC version requested by app; must be incremented when a method is changed
           or added; hub must support all of RPC versions
    :param auth_account: any valid account; used only for establishing WebSocket connection
    :param conv_id: conversation ID; unique, generated by app to uniquely identify this session
    """
    try:
        account = db.Account.validate_login_key(
            auth_account, allowed_kinds=db.admin_manager_or_coupon
        )
    except Exception as e:
        if type(e) is HTTPException:
            logger.info(f"B12874 invalid auth_account: {e.detail}")
        else:
            logger.info(f"B23915 validation error {type(e)}")
        await websocket.close()
        # respond with '403 Forbidden' here (same as invalid URLs) to make it harder for those
        # without a valid coupon or login key to detect that this is a BitBurrow hub;
        # test with curl as WebSocket client:
        #     HOST="vxm.example.org:8443"
        #     URL="https://$HOST/rpc1/BBBBBBBBBBBBBBBBBB/4"
        #     curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" \
        #         -H "Sec-WebSocket-Key: $(openssl rand -base64 16)" \
        #         -H "Sec-WebSocket-Version: 13" \
        #         -H "Host: $HOST" -H "Origin: $URL" "$URL"
        raise HTTPException(status_code=403, detail="")
    if conv_id not in messages:
        log_id = conv_id[-4:]  # only for logging
        pws_log = logging.getLogger('persistent_websocket')
        pws_log.setLevel(logging.DEBUG)  # will be throttled by handler log level (file, console)
        messages[conv_id] = persistent_websocket.PersistentWebsocket(log_id, pws_log)
    try:
        await websocket.accept()
        # Notes on RPC options (see https://pypi.org/project/PACKAGE/ where PACKAGE is below):
        #     * fastapi-jsonrpc → can only use HTTP (no PersistentWebsocket); snyk.io 72
        #     * grpc → uses HTTP/2; does not gracefully recover from disconnects; snyk.io 63
        #     * json-rpc → simple, no async but seems to work well; snyk.io 71
        async for m in messages[conv_id].connected(websocket):
            response = jsonrpc.JSONRPCResponseManager.handle(m, jsonrpc.dispatcher)
            await messages[conv_id].send(json.dumps(db.simplify(response.data)))
    except persistent_websocket.PWUnrecoverableError:
        del messages[conv_id]  # data is no longer usable


@router.post('/v1/coupons/{coupon}/managers')
async def create_manager(request: Request, coupon: str):
    account = db.Account.validate_login_key(coupon, allowed_kinds=db.coupon)
    login_key = db.Account.new(db.Account_kind.MANAGER)
    return responses.JSONResponse(
        status_code=status.HTTP_201_CREATED,
        content={'login_key': login_key},
    )
    # do not store login_key!


@jsonrpc.dispatcher.add_method
def list_servers(login_key: str):
    account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
    with Session(db.engine) as session:
        statement = select(db.Server).where(db.Server.account_id == account.id)
        return list(session.exec(statement))


@router.post('/v1/managers/{login_key}/servers', status_code=status.HTTP_201_CREATED)
async def new_server(login_key: str):
    account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
    server_id = db.Server.new(account.id)
    return server_id


@router.websocket('/v1/managers/{login_key}/servers/{server_id}/setup')
async def websocket_setup(websocket: WebSocket, login_key: str, server_id: int):
    account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
    await websocket.accept()
    pws_log = logging.getLogger('persistent_websocket')
    pws_log.setLevel(logging.DEBUG)  # will be throttled by handler log level (file, console)
    messages = persistent_websocket.PersistentWebsocket(server_id, pws_log)
    runTasks = transmutation.ServerSetup(websocket, messages)
    try:
        await runTasks.transmute_steps()
    except asyncio.exceptions.CancelledError:
        logger.info(f"B15058 transmute canceled")


@router.websocket('/v1/managers/{login_key}/servers/{server_id}/proxy')
async def websocket_proxy(websocket: WebSocket, login_key: str, server_id: int):
    account = db.Account.validate_login_key(login_key, allowed_kinds=db.admin_or_manager)
    await websocket.accept()
    tcp_websocket = transmutation.TcpWebSocket(
        tcp_port=30915, tcp_address='127.0.0.1', ws=websocket
    )
    await tcp_websocket.start()
    try:
        await websocket.close()
    except Exception as e:
        logger.error(f"B38264 WebSocket error: {e}")  # e.g. websocket already closed


# messages: Dict[str, persistent_websocket.PersistentWebsocket] = dict()  # one entry for each client


# @router.websocket('/v1/pw/{client_id}')
# async def websocket_testahwibb(websocket: WebSocket, client_id: str):
#     if client_id not in messages:
#         # FIXME: mitigate DOS attack via opening a bunch of unique connections
#         messages[client_id] = persistent_websocket.PersistentWebsocket(client_id)
#         # (TESTING) messages[client_id].chaos = 50  # 5% chance of closing WebSocket on each send or receive
#         persistent_websocket.logger.setLevel(logging.DEBUG)
#     try:
#         await websocket.accept()
#         async for m in messages[client_id].connected(websocket):
#             print(f"------------------------------------------ {client_id} incoming: {m.decode()}")
#     except persistent_websocket.PWUnrecoverableError:
#         del messages[client_id]  # data is no longer usable
